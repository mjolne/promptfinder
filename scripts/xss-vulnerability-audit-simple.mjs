#!/usr/bin/env node
/**
 * Simple XSS Vulnerability Audit Script
 * Focuses on real XSS vulnerabilities in user input handling and data display
 */

import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

/**
 * XSS audit results
 */
const auditResults = {
  timestamp: new Date().toISOString(),
  overall: {
    score: 0,
    grade: '',
    criticalIssues: 0,
    warnings: 0,
    passed: 0,
  },
  findings: [],
  summary: {
    htmlEscaping: { status: 'unknown', details: '' },
    contentSecurityPolicy: { status: 'unknown', details: '' },
    dangerousInnerHTML: { count: 0, details: [] },
    inputValidation: { status: 'unknown', details: '' },
    outputEscaping: { count: 0, details: [] },
  },
};

/**
 * Add audit finding
 */
function addFinding(severity, title, description, recommendation, file = null, line = null) {
  const finding = {
    severity,
    title,
    description,
    recommendation,
    file,
    line,
    timestamp: new Date().toISOString(),
  };

  auditResults.findings.push(finding);

  switch (severity) {
    case 'critical':
      auditResults.overall.criticalIssues++;
      break;
    case 'warning':
      auditResults.overall.warnings++;
      break;
    case 'pass':
      auditResults.overall.passed++;
      break;
  }
}

/**
 * Analyze HTML escaping implementation
 */
function analyzeHTMLEscaping() {
  console.log('üîç Analyzing HTML escaping implementation...');

  try {
    const utilsContent = readFileSync(join(projectRoot, 'js/utils.js'), 'utf8');

    // Check if escapeHTML function exists
    const escapeHTMLMatch = utilsContent.match(/export const escapeHTML = ([^}]+})/s);

    if (escapeHTMLMatch) {
      const escapeFunction = escapeHTMLMatch[1];

      // Check which XSS characters are handled
      const xssChars = [
        { char: '&', entity: '&amp;', critical: true },
        { char: '<', entity: '&lt;', critical: true },
        { char: '>', entity: '&gt;', critical: true },
        { char: '"', entity: '&quot;', critical: true },
        { char: "'", entity: '&#39;', critical: false },
        { char: '/', entity: '&#x2F;', critical: false },
      ];

      let handledCount = 0;
      let criticalHandled = 0;
      const missingChars = [];

      xssChars.forEach(({ char, entity, critical }) => {
        // Check if character is in the character set and entity is in the replacement object
        const hasChar =
          escapeFunction.includes(`'${char}'`) || escapeFunction.includes(`"${char}"`);
        const hasEntity = escapeFunction.includes(entity);

        if (hasChar && hasEntity) {
          handledCount++;
          if (critical) criticalHandled++;
        } else {
          missingChars.push(char);
        }
      });

      auditResults.summary.htmlEscaping = {
        status: criticalHandled >= 4 ? 'good' : 'incomplete',
        details: `Handles ${handledCount}/6 XSS characters (${criticalHandled}/4 critical)`,
      };

      if (criticalHandled >= 4) {
        addFinding(
          'pass',
          'Comprehensive HTML escaping function',
          `HTML escaping function handles ${handledCount}/6 XSS characters including all critical ones.`,
          'Continue using this function for all user-generated content.',
          'js/utils.js'
        );
      } else {
        addFinding(
          'warning',
          'Incomplete HTML escaping',
          `HTML escaping function missing critical characters: ${missingChars.join(', ')}`,
          'Add escaping for missing critical XSS characters.',
          'js/utils.js'
        );
      }
    } else {
      auditResults.summary.htmlEscaping = {
        status: 'missing',
        details: 'No HTML escaping function found',
      };

      addFinding(
        'critical',
        'No HTML escaping function',
        'No HTML escaping function found in utilities.',
        'Implement a comprehensive HTML escaping function.',
        'js/utils.js'
      );
    }
  } catch (error) {
    addFinding(
      'warning',
      'Cannot analyze HTML escaping',
      'Unable to read js/utils.js for HTML escaping analysis.',
      'Manually verify HTML escaping implementation.'
    );
  }
}

/**
 * Analyze Content Security Policy
 */
function analyzeCSP() {
  console.log('üîç Analyzing Content Security Policy...');

  try {
    const manifest = JSON.parse(readFileSync(join(projectRoot, 'manifest.json'), 'utf8'));

    if (manifest.content_security_policy && manifest.content_security_policy.extension_pages) {
      const csp = manifest.content_security_policy.extension_pages;

      const issues = [];
      const strengths = [];

      // Check for unsafe directives
      if (csp.includes("'unsafe-inline'")) {
        issues.push("allows 'unsafe-inline'");
        addFinding(
          'critical',
          'CSP allows unsafe-inline',
          'Content Security Policy allows unsafe-inline, enabling XSS attacks.',
          "Remove 'unsafe-inline' from CSP.",
          'manifest.json'
        );
      } else {
        strengths.push("blocks 'unsafe-inline'");
      }

      if (csp.includes("'unsafe-eval'")) {
        issues.push("allows 'unsafe-eval'");
        addFinding(
          'critical',
          'CSP allows unsafe-eval',
          'Content Security Policy allows unsafe-eval, enabling code injection.',
          "Remove 'unsafe-eval' from CSP.",
          'manifest.json'
        );
      } else {
        strengths.push("blocks 'unsafe-eval'");
      }

      // Check for proper script-src
      if (csp.includes("script-src 'self'")) {
        strengths.push("restricts script sources to 'self'");
      }

      auditResults.summary.contentSecurityPolicy = {
        status: issues.length === 0 ? 'good' : 'issues',
        details:
          issues.length > 0 ? `Issues: ${issues.join(', ')}` : `Strengths: ${strengths.join(', ')}`,
      };

      if (issues.length === 0) {
        addFinding(
          'pass',
          'Secure Content Security Policy',
          'CSP properly blocks dangerous inline execution and eval.',
          'Continue maintaining secure CSP configuration.',
          'manifest.json'
        );
      }
    } else {
      auditResults.summary.contentSecurityPolicy = {
        status: 'missing',
        details: 'No CSP found in manifest',
      };

      addFinding(
        'critical',
        'No Content Security Policy',
        'No Content Security Policy defined.',
        'Add a comprehensive CSP to prevent XSS attacks.',
        'manifest.json'
      );
    }
  } catch (error) {
    addFinding(
      'critical',
      'Cannot analyze CSP',
      'Unable to read manifest.json for CSP analysis.',
      'Ensure manifest.json exists and is valid.'
    );
  }
}

/**
 * Analyze dangerous innerHTML usage
 */
function analyzeDangerousInnerHTML() {
  console.log('üîç Analyzing innerHTML usage patterns...');

  const filesToCheck = ['js/ui.js', 'js/utils.js', 'app.js', 'js/toast.js'];

  let totalInnerHTML = 0;
  let dangerousUsage = 0;
  const details = [];

  filesToCheck.forEach(file => {
    try {
      const content = readFileSync(join(projectRoot, file), 'utf8');
      const lines = content.split('\n');

      // Find innerHTML usage
      const innerHTMLRegex = /\.innerHTML\s*=/g;
      let match;

      while ((match = innerHTMLRegex.exec(content)) !== null) {
        totalInnerHTML++;
        const lineIndex = content.substring(0, match.index).split('\n').length - 1;
        const line = lines[lineIndex];
        const lineNumber = lineIndex + 1;

        // Check context for user input
        const context = lines.slice(Math.max(0, lineIndex - 2), lineIndex + 3).join('\n');

        if (context.includes('Utils.escapeHTML') || context.includes('escapeHTML')) {
          addFinding(
            'pass',
            'Safe innerHTML usage with escaping',
            `innerHTML used with proper HTML escaping: ${line.trim()}`,
            'Continue using HTML escaping.',
            file,
            lineNumber
          );
        } else if (context.includes('getText(') || line.includes("''") || line.includes('""')) {
          // Likely safe - using constants or clearing content
          addFinding(
            'pass',
            'Safe innerHTML usage',
            `innerHTML used safely (constants/clearing): ${line.trim()}`,
            'Continue safe usage patterns.',
            file,
            lineNumber
          );
        } else {
          dangerousUsage++;
          details.push(`${file}:${lineNumber}`);

          addFinding(
            'warning',
            'Potentially unsafe innerHTML usage',
            `innerHTML usage without obvious escaping: ${line.trim()}`,
            'Verify content is safe or add HTML escaping.',
            file,
            lineNumber
          );
        }
      }
    } catch (error) {
      // File doesn't exist or can't be read
    }
  });

  auditResults.summary.dangerousInnerHTML = {
    count: totalInnerHTML,
    details: details,
  };
}

/**
 * Analyze input validation patterns
 */
function analyzeInputValidation() {
  console.log('üîç Analyzing input validation patterns...');

  try {
    const popupHTML = readFileSync(join(projectRoot, 'pages/popup.html'), 'utf8');
    const appJS = readFileSync(join(projectRoot, 'app.js'), 'utf8');

    const validationFeatures = [];

    // Check for HTML5 validation
    if (popupHTML.includes('required') && popupHTML.includes('minlength')) {
      validationFeatures.push('HTML5 validation attributes');
    }

    if (popupHTML.includes('type="email"')) {
      validationFeatures.push('Email input validation');
    }

    // Check for JavaScript validation
    if (appJS.includes('.trim()') && appJS.includes('validation')) {
      validationFeatures.push('JavaScript validation');
    }

    auditResults.summary.inputValidation = {
      status: validationFeatures.length > 0 ? 'implemented' : 'limited',
      details: validationFeatures.join(', '),
    };

    if (validationFeatures.length >= 2) {
      addFinding(
        'pass',
        'Multiple input validation layers',
        `Implemented: ${validationFeatures.join(', ')}`,
        'Continue using comprehensive input validation.',
        'pages/popup.html'
      );
    } else {
      addFinding(
        'warning',
        'Limited input validation',
        'Limited input validation implementation found.',
        'Implement comprehensive client and server-side validation.',
        'pages/popup.html'
      );
    }
  } catch (error) {
    addFinding(
      'warning',
      'Cannot analyze input validation',
      'Unable to analyze input validation patterns.',
      'Manually review input validation implementation.'
    );
  }
}

/**
 * Check for proper output escaping usage
 */
function analyzeOutputEscaping() {
  console.log('üîç Analyzing output escaping usage...');

  const filesToCheck = ['js/ui.js', 'js/utils.js'];
  let escapingUsage = 0;
  const details = [];

  filesToCheck.forEach(file => {
    try {
      const content = readFileSync(join(projectRoot, file), 'utf8');

      // Count escapeHTML usage
      const escapingMatches = content.match(/Utils\.escapeHTML\(/g) || [];
      escapingUsage += escapingMatches.length;

      if (escapingMatches.length > 0) {
        details.push(`${file}: ${escapingMatches.length} instances`);
      }
    } catch (error) {
      // File doesn't exist
    }
  });

  auditResults.summary.outputEscaping = {
    count: escapingUsage,
    details: details,
  };

  if (escapingUsage >= 5) {
    addFinding(
      'pass',
      'Good output escaping usage',
      `HTML escaping used ${escapingUsage} times across UI components.`,
      'Continue using escaping for all user content.',
      'js/ui.js'
    );
  } else if (escapingUsage > 0) {
    addFinding(
      'warning',
      'Limited output escaping usage',
      `HTML escaping used only ${escapingUsage} times. May need more coverage.`,
      'Increase usage of HTML escaping for user content.',
      'js/ui.js'
    );
  } else {
    addFinding(
      'critical',
      'No output escaping found',
      'No HTML escaping usage found in UI components.',
      'Implement HTML escaping for all user-generated content.',
      'js/ui.js'
    );
  }
}

/**
 * Calculate overall security score
 */
function calculateSecurityScore() {
  const total =
    auditResults.overall.criticalIssues +
    auditResults.overall.warnings +
    auditResults.overall.passed;
  if (total === 0) return 0;

  const criticalWeight = -15;
  const warningWeight = -3;
  const passWeight = 5;

  const score =
    auditResults.overall.criticalIssues * criticalWeight +
    auditResults.overall.warnings * warningWeight +
    auditResults.overall.passed * passWeight;

  const maxPossibleScore = total * passWeight;
  const normalizedScore = Math.max(0, Math.min(100, (score / maxPossibleScore) * 100));

  auditResults.overall.score = Math.round(normalizedScore);

  if (normalizedScore >= 90) auditResults.overall.grade = 'A';
  else if (normalizedScore >= 80) auditResults.overall.grade = 'B';
  else if (normalizedScore >= 70) auditResults.overall.grade = 'C';
  else if (normalizedScore >= 60) auditResults.overall.grade = 'D';
  else auditResults.overall.grade = 'F';
}

/**
 * Display audit results
 */
function displayResults() {
  console.log('\nüõ°Ô∏è XSS Vulnerability Audit Results');
  console.log('===================================\n');

  console.log(
    `üìä Overall Security Score: ${auditResults.overall.score}/100 (Grade: ${auditResults.overall.grade})`
  );
  console.log(
    `üéØ Summary: ${auditResults.overall.passed} passed, ${auditResults.overall.warnings} warnings, ${auditResults.overall.criticalIssues} critical\n`
  );

  // Summary overview
  console.log('üìã SECURITY OVERVIEW:');
  console.log(
    `  üîí HTML Escaping: ${auditResults.summary.htmlEscaping.status} (${auditResults.summary.htmlEscaping.details})`
  );
  console.log(
    `  üõ°Ô∏è Content Security Policy: ${auditResults.summary.contentSecurityPolicy.status} (${auditResults.summary.contentSecurityPolicy.details})`
  );
  console.log(
    `  ‚ö†Ô∏è innerHTML Usage: ${auditResults.summary.dangerousInnerHTML.count} instances found`
  );
  console.log(
    `  ‚úÖ Input Validation: ${auditResults.summary.inputValidation.status} (${auditResults.summary.inputValidation.details})`
  );
  console.log(
    `  üîê Output Escaping: ${auditResults.summary.outputEscaping.count} instances used\n`
  );

  // Detailed findings
  console.log('üîç DETAILED FINDINGS:');
  auditResults.findings.forEach(finding => {
    const icon =
      finding.severity === 'critical' ? 'üö®' : finding.severity === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';
    console.log(`  ${icon} ${finding.title}`);
    console.log(`     ${finding.description}`);
    if (finding.file) {
      const location = finding.line ? `${finding.file}:${finding.line}` : finding.file;
      console.log(`     File: ${location}`);
    }
    console.log(`     Recommendation: ${finding.recommendation}\n`);
  });

  // Priority recommendations
  console.log('üéØ PRIORITY RECOMMENDATIONS:');
  if (auditResults.overall.criticalIssues > 0) {
    console.log('  üö® CRITICAL: Address all critical XSS vulnerabilities immediately');
  }
  if (auditResults.overall.warnings > 0) {
    console.log('  ‚ö†Ô∏è WARNING: Review and address warning-level security concerns');
  }
  if (auditResults.overall.score >= 80) {
    console.log('  ‚úÖ GOOD: Solid XSS protection - continue monitoring');
  } else {
    console.log('  üîß IMPROVEMENT NEEDED: Strengthen XSS protection measures');
  }

  console.log('\nüõ°Ô∏è XSS PROTECTION BEST PRACTICES:');
  console.log('  ‚Ä¢ Escape all user input before displaying (Utils.escapeHTML)');
  console.log('  ‚Ä¢ Use textContent instead of innerHTML when possible');
  console.log('  ‚Ä¢ Maintain strict Content Security Policy');
  console.log('  ‚Ä¢ Validate all user inputs on client and server side');
  console.log('  ‚Ä¢ Use parameterized queries for database operations');
}

/**
 * Main audit execution
 */
function runXSSAudit() {
  console.log('üõ°Ô∏è Starting Comprehensive XSS Vulnerability Audit...\n');

  analyzeHTMLEscaping();
  analyzeCSP();
  analyzeDangerousInnerHTML();
  analyzeInputValidation();
  analyzeOutputEscaping();

  calculateSecurityScore();
  displayResults();

  // Save results
  try {
    const resultsPath = join(projectRoot, 'xss-audit-results-simple.json');
    writeFileSync(resultsPath, JSON.stringify(auditResults, null, 2));
    console.log(`\nüìÑ Detailed audit results saved to: xss-audit-results-simple.json`);
  } catch (err) {
    console.log('\nüìÑ Results not saved due to filesystem access limitation');
  }

  return auditResults;
}

// Run the audit
runXSSAudit();
