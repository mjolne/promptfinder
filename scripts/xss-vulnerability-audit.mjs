#!/usr/bin/env node
/**
 * XSS Vulnerability Audit Script
 * Tests for Cross-Site Scripting vulnerabilities in user input handling and data display
 */

import { readFileSync, writeFileSync, readdirSync } from 'fs';
import { join, dirname, extname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

/**
 * XSS audit results
 */
const auditResults = {
  timestamp: new Date().toISOString(),
  overall: {
    score: 0,
    grade: '',
    criticalIssues: 0,
    warnings: 0,
    passed: 0,
  },
  categories: {
    inputValidation: [],
    outputEscaping: [],
    domManipulation: [],
    contentSecurityPolicy: [],
    urlHandling: [],
    eventHandlers: [],
  },
  files: {},
};

/**
 * Common XSS payloads for testing
 */
const XSS_PAYLOADS = [
  '<script>alert("XSS")</script>',
  '"><script>alert("XSS")</script>',
  "';alert('XSS');//",
  'javascript:alert("XSS")',
  '<img src=x onerror=alert("XSS")>',
  '<svg onload=alert("XSS")>',
  '<iframe src="javascript:alert(\'XSS\')">',
  '<object data="javascript:alert(\'XSS\')">',
  '<embed src="javascript:alert(\'XSS\')">',
  '<form><button formaction="javascript:alert(\'XSS\')">',
  '<input onfocus=alert("XSS") autofocus>',
  '<select onfocus=alert("XSS") autofocus>',
  '<textarea onfocus=alert("XSS") autofocus>',
  '<keygen onfocus=alert("XSS") autofocus>',
  '<video><source onerror="alert(\'XSS\')">',
  '<audio src=x onerror=alert("XSS")>',
  '<details open ontoggle=alert("XSS")>',
  '<marquee onstart=alert("XSS")>',
  '<style>@import"javascript:alert(\'XSS\')"</style>',
  '<link rel=stylesheet href="javascript:alert(\'XSS\')">',
];

/**
 * Dangerous DOM methods that can lead to XSS
 */
const DANGEROUS_DOM_METHODS = [
  { method: 'innerHTML', level: 'warning' },
  { method: 'outerHTML', level: 'critical' },
  { method: 'insertAdjacentHTML', level: 'critical' },
  { method: 'document\\.write\\(', level: 'critical' },
  { method: 'document\\.writeln\\(', level: 'critical' },
  { method: '\\beval\\(', level: 'critical' },
  { method: 'new Function\\(', level: 'critical' },
  { method: 'execScript', level: 'critical' },
];

/**
 * Add audit finding
 */
function addFinding(
  category,
  severity,
  title,
  description,
  recommendation,
  file = null,
  line = null,
  codeSnippet = null
) {
  const finding = {
    severity,
    title,
    description,
    recommendation,
    file,
    line,
    codeSnippet,
    timestamp: new Date().toISOString(),
  };

  auditResults.categories[category].push(finding);

  if (!auditResults.files[file]) {
    auditResults.files[file] = { criticalIssues: 0, warnings: 0, passed: 0 };
  }

  switch (severity) {
    case 'critical':
      auditResults.overall.criticalIssues++;
      auditResults.files[file].criticalIssues++;
      break;
    case 'warning':
      auditResults.overall.warnings++;
      auditResults.files[file].warnings++;
      break;
    case 'pass':
      auditResults.overall.passed++;
      auditResults.files[file].passed++;
      break;
  }
}

/**
 * Analyze a file for XSS vulnerabilities
 */
function analyzeFile(filePath, content) {
  const relativePath = filePath.replace(projectRoot + '/', '');
  const lines = content.split('\n');

  // Track innerHTML usage
  analyzeInnerHTMLUsage(relativePath, content, lines);

  // Track input handling
  analyzeInputHandling(relativePath, content, lines);

  // Track URL handling
  analyzeURLHandling(relativePath, content, lines);

  // Track event handlers
  analyzeEventHandlers(relativePath, content, lines);

  // Track output escaping
  analyzeOutputEscaping(relativePath, content, lines);
}

/**
 * Analyze innerHTML and dangerous DOM method usage
 */
function analyzeInnerHTMLUsage(filePath, content, lines) {
  DANGEROUS_DOM_METHODS.forEach(method => {
    const regex = new RegExp(`\\b${method}\\b`, 'gi');
    const matches = [...content.matchAll(regex)];

    matches.forEach(match => {
      const lineIndex = content.substring(0, match.index).split('\n').length - 1;
      const line = lines[lineIndex];
      const lineNumber = lineIndex + 1;

      // Check if it's in a dangerous context
      if (method === 'innerHTML') {
        // Check if it's being used with user input or dynamic content
        const context = lines.slice(Math.max(0, lineIndex - 2), lineIndex + 3).join('\n');

        if (
          context.includes('value') ||
          context.includes('input') ||
          context.includes('userCredential') ||
          context.includes('prompt') ||
          context.includes('displayName') ||
          context.includes('email')
        ) {
          addFinding(
            'domManipulation',
            'critical',
            `Dangerous innerHTML usage with potential user input`,
            `innerHTML is used in a context where user input might be involved, creating XSS risk.`,
            'Replace innerHTML with textContent or use proper HTML escaping.',
            filePath,
            lineNumber,
            line.trim()
          );
        } else if (context.includes('Utils.escapeHTML') || context.includes('escapeHTML')) {
          addFinding(
            'domManipulation',
            'pass',
            'innerHTML usage with proper escaping',
            'innerHTML is used but with proper HTML escaping function.',
            'Continue using HTML escaping for all dynamic content.',
            filePath,
            lineNumber,
            line.trim()
          );
        } else {
          addFinding(
            'domManipulation',
            'warning',
            'innerHTML usage detected',
            `innerHTML usage found. Verify that no user input is involved: ${line.trim()}`,
            'Ensure all content passed to innerHTML is properly escaped or use textContent instead.',
            filePath,
            lineNumber,
            line.trim()
          );
        }
      } else {
        addFinding(
          'domManipulation',
          'critical',
          `Dangerous DOM method: ${method}`,
          `Usage of ${method} can lead to code injection vulnerabilities.`,
          `Replace ${method} with safer alternatives or ensure proper input validation.`,
          filePath,
          lineNumber,
          line.trim()
        );
      }
    });
  });

  // Check for safe alternatives
  const safeMethodsRegex = /(textContent|innerText)/gi;
  const safeMatches = [...content.matchAll(safeMethodsRegex)];

  if (safeMatches.length > 0) {
    addFinding(
      'domManipulation',
      'pass',
      'Safe DOM manipulation methods used',
      `File uses safe DOM methods like textContent/innerText (${safeMatches.length} instances).`,
      'Continue using safe DOM manipulation methods.',
      filePath
    );
  }
}

/**
 * Analyze input handling and validation
 */
function analyzeInputHandling(filePath, content, lines) {
  // Check for form inputs
  const inputRegex = /(?:input|textarea|select).*(?:value|textContent|innerHTML)/gi;
  const inputMatches = [...content.matchAll(inputRegex)];

  inputMatches.forEach(match => {
    const lineIndex = content.substring(0, match.index).split('\n').length - 1;
    const lineNumber = lineIndex + 1;
    const line = lines[lineIndex];

    // Check for validation
    const context = lines.slice(Math.max(0, lineIndex - 5), lineIndex + 5).join('\n');

    if (
      context.includes('trim()') ||
      context.includes('validate') ||
      context.includes('required')
    ) {
      addFinding(
        'inputValidation',
        'pass',
        'Input validation detected',
        'Input field has validation or sanitization.',
        'Ensure validation covers all XSS attack vectors.',
        filePath,
        lineNumber,
        line.trim()
      );
    } else {
      addFinding(
        'inputValidation',
        'warning',
        'Input without apparent validation',
        'Input field lacks obvious validation or sanitization.',
        'Add input validation and sanitization.',
        filePath,
        lineNumber,
        line.trim()
      );
    }
  });

  // Check for HTML escaping function usage
  if (content.includes('escapeHTML') || content.includes('Utils.escapeHTML')) {
    addFinding(
      'outputEscaping',
      'pass',
      'HTML escaping function used',
      'Code uses HTML escaping functions for output.',
      'Ensure all user content is escaped before display.',
      filePath
    );
  }

  // Check for form validation attributes
  if (
    content.includes('required') ||
    content.includes('minlength') ||
    content.includes('maxlength')
  ) {
    addFinding(
      'inputValidation',
      'pass',
      'HTML5 form validation attributes',
      'Form uses HTML5 validation attributes.',
      'Supplement with server-side validation.',
      filePath
    );
  }
}

/**
 * Analyze URL handling for XSS vulnerabilities
 */
function analyzeURLHandling(filePath, content, lines) {
  // Check for javascript: protocol usage
  const jsProtocolRegex = /javascript:/gi;
  const jsMatches = [...content.matchAll(jsProtocolRegex)];

  jsMatches.forEach(match => {
    const lineIndex = content.substring(0, match.index).split('\n').length - 1;
    const lineNumber = lineIndex + 1;
    const line = lines[lineIndex];

    addFinding(
      'urlHandling',
      'critical',
      'JavaScript protocol usage',
      'javascript: protocol can be used for XSS attacks.',
      'Remove javascript: protocol usage or properly validate URLs.',
      filePath,
      lineNumber,
      line.trim()
    );
  });

  // Check for URL construction with user input
  const urlRegex = /(href|src|action)\s*=\s*["`']?[^"`'\s>]*\+/gi;
  const urlMatches = [...content.matchAll(urlRegex)];

  urlMatches.forEach(match => {
    const lineIndex = content.substring(0, match.index).split('\n').length - 1;
    const lineNumber = lineIndex + 1;
    const line = lines[lineIndex];

    addFinding(
      'urlHandling',
      'warning',
      'Dynamic URL construction',
      'URL is constructed dynamically, ensure proper validation.',
      'Validate and sanitize all URL components.',
      filePath,
      lineNumber,
      line.trim()
    );
  });
}

/**
 * Analyze event handlers for XSS vulnerabilities
 */
function analyzeEventHandlers(filePath, content, lines) {
  // Check for inline event handlers
  const eventRegex = /\bon\w+\s*=/gi;
  const eventMatches = [...content.matchAll(eventRegex)];

  eventMatches.forEach(match => {
    const lineIndex = content.substring(0, match.index).split('\n').length - 1;
    const lineNumber = lineIndex + 1;
    const line = lines[lineIndex];

    // Check if it's in HTML or in a string that might be used as HTML
    const context = lines.slice(Math.max(0, lineIndex - 2), lineIndex + 3).join('\n');

    if (context.includes('addEventListener') || context.includes('onclick =')) {
      addFinding(
        'eventHandlers',
        'pass',
        'Proper event handler attachment',
        'Event handlers are attached using addEventListener or proper JS assignment.',
        'Continue using proper event handler attachment methods.',
        filePath,
        lineNumber,
        line.trim()
      );
    } else {
      addFinding(
        'eventHandlers',
        'warning',
        'Inline event handler detected',
        'Inline event handlers can be exploited for XSS.',
        'Use addEventListener instead of inline event handlers.',
        filePath,
        lineNumber,
        line.trim()
      );
    }
  });
}

/**
 * Analyze output escaping mechanisms
 */
function analyzeOutputEscaping(filePath, content, lines) {
  // Check for template literals with user data
  const templateRegex = /`[^`]*\$\{[^}]*\}[^`]*`/g;
  const templateMatches = [...content.matchAll(templateRegex)];

  templateMatches.forEach(match => {
    const lineIndex = content.substring(0, match.index).split('\n').length - 1;
    const lineNumber = lineIndex + 1;
    const line = lines[lineIndex];

    if (match[0].includes('escapeHTML') || match[0].includes('Utils.escapeHTML')) {
      addFinding(
        'outputEscaping',
        'pass',
        'Template literal with proper escaping',
        'Template literal uses HTML escaping for dynamic content.',
        'Continue using HTML escaping in template literals.',
        filePath,
        lineNumber,
        line.trim()
      );
    } else if (
      match[0].includes('prompt') ||
      match[0].includes('user') ||
      match[0].includes('displayName')
    ) {
      addFinding(
        'outputEscaping',
        'warning',
        'Template literal with potential user content',
        'Template literal may contain user content without escaping.',
        'Add HTML escaping for all user-generated content in templates.',
        filePath,
        lineNumber,
        line.trim()
      );
    }
  });
}

/**
 * Analyze Content Security Policy
 */
function analyzeCSP() {
  console.log('🔍 Analyzing Content Security Policy...');

  try {
    const manifest = JSON.parse(readFileSync(join(projectRoot, 'manifest.json'), 'utf8'));

    if (manifest.content_security_policy && manifest.content_security_policy.extension_pages) {
      const csp = manifest.content_security_policy.extension_pages;

      // Check for unsafe-inline
      if (csp.includes("'unsafe-inline'")) {
        addFinding(
          'contentSecurityPolicy',
          'critical',
          'CSP allows unsafe-inline',
          'Content Security Policy allows unsafe-inline, which can enable XSS attacks.',
          "Remove 'unsafe-inline' from CSP and use nonces or hashes for inline scripts/styles.",
          'manifest.json'
        );
      } else {
        addFinding(
          'contentSecurityPolicy',
          'pass',
          'CSP blocks unsafe-inline',
          'Content Security Policy properly blocks unsafe-inline execution.',
          'Continue blocking unsafe-inline execution.',
          'manifest.json'
        );
      }

      // Check for unsafe-eval
      if (csp.includes("'unsafe-eval'")) {
        addFinding(
          'contentSecurityPolicy',
          'critical',
          'CSP allows unsafe-eval',
          'Content Security Policy allows unsafe-eval, which can enable code injection.',
          "Remove 'unsafe-eval' from CSP.",
          'manifest.json'
        );
      } else {
        addFinding(
          'contentSecurityPolicy',
          'pass',
          'CSP blocks unsafe-eval',
          'Content Security Policy properly blocks eval() and similar functions.',
          'Continue blocking eval() execution.',
          'manifest.json'
        );
      }

      // Check for script-src restrictions
      if (csp.includes("script-src 'self'")) {
        addFinding(
          'contentSecurityPolicy',
          'pass',
          'CSP restricts script sources',
          'Content Security Policy restricts script sources to self.',
          'Continue restricting script sources.',
          'manifest.json'
        );
      }
    } else {
      addFinding(
        'contentSecurityPolicy',
        'critical',
        'No Content Security Policy',
        'No Content Security Policy defined in manifest.',
        'Add a comprehensive CSP to prevent XSS attacks.',
        'manifest.json'
      );
    }
  } catch (error) {
    addFinding(
      'contentSecurityPolicy',
      'critical',
      'Cannot analyze CSP',
      'Unable to read or parse manifest.json for CSP analysis.',
      'Ensure manifest.json exists and contains valid CSP configuration.'
    );
  }
}

/**
 * Test XSS payloads against input validation
 */
function testXSSPayloads() {
  console.log('🔍 Testing XSS payload resistance...');

  try {
    const utilsContent = readFileSync(join(projectRoot, 'js/utils.js'), 'utf8');

    // Check if escapeHTML function exists
    if (utilsContent.includes('escapeHTML')) {
      // Extract the escapeHTML function
      const escapeHTMLMatch = utilsContent.match(/export const escapeHTML = ([^;]+);/s);

      if (escapeHTMLMatch) {
        addFinding(
          'outputEscaping',
          'pass',
          'HTML escaping function implemented',
          'Project includes a dedicated HTML escaping function.',
          'Ensure all user content passes through this function before display.',
          'js/utils.js'
        );

        // Test if it handles common XSS characters by checking the replacement patterns
        const escapeFunction = escapeHTMLMatch[1];
        const xssChars = ['&', '<', '>', '"', "'", '/'];
        const expectedReplacements = ['&amp;', '&lt;', '&gt;', '&quot;', '&#39;', '&#x2F;'];

        let handledCount = 0;
        xssChars.forEach((char, index) => {
          const expectedReplacement = expectedReplacements[index];
          if (
            escapeFunction.includes(`'${char}'`) &&
            escapeFunction.includes(expectedReplacement)
          ) {
            handledCount++;
          }
        });

        if (handledCount >= 5) {
          addFinding(
            'outputEscaping',
            'pass',
            'Comprehensive HTML escaping',
            `HTML escaping function handles ${handledCount}/6 critical XSS characters with proper entity encoding.`,
            'Excellent HTML escaping implementation - continue using for all user content.',
            'js/utils.js'
          );
        } else {
          addFinding(
            'outputEscaping',
            'warning',
            'Incomplete HTML escaping',
            `HTML escaping function only handles ${handledCount}/6 critical XSS characters.`,
            'Ensure all XSS-prone characters are properly escaped.',
            'js/utils.js'
          );
        }
      }
    } else {
      addFinding(
        'outputEscaping',
        'critical',
        'No HTML escaping function',
        'No HTML escaping function found in utils.',
        'Implement a comprehensive HTML escaping function.',
        'js/utils.js'
      );
    }
  } catch (error) {
    addFinding(
      'outputEscaping',
      'warning',
      'Cannot test XSS payload resistance',
      'Unable to analyze HTML escaping implementation.',
      'Manually verify HTML escaping functionality.'
    );
  }
}

/**
 * Get all JavaScript and HTML files to analyze
 */
function getFilesToAnalyze() {
  // Manually specify key files for analysis to ensure they're found
  const keyFiles = [
    'js/utils.js',
    'js/ui.js',
    'app.js',
    'pages/popup.html',
    'js/promptData.js',
    'js/toast.js',
    'js/analytics/analytics.js',
    'js/analytics/event-tracker.js',
  ];

  const files = [];

  keyFiles.forEach(file => {
    const fullPath = join(projectRoot, file);
    try {
      readFileSync(fullPath, 'utf8');
      files.push(fullPath);
    } catch (error) {
      // File doesn't exist or can't be read
    }
  });

  return files;
}

/**
 * Calculate overall security score
 */
function calculateSecurityScore() {
  const total =
    auditResults.overall.criticalIssues +
    auditResults.overall.warnings +
    auditResults.overall.passed;
  if (total === 0) return 0;

  const criticalWeight = -10;
  const warningWeight = -3;
  const passWeight = 5;

  const score =
    auditResults.overall.criticalIssues * criticalWeight +
    auditResults.overall.warnings * warningWeight +
    auditResults.overall.passed * passWeight;

  // Normalize to 0-100 scale
  const maxPossibleScore = total * passWeight;
  const normalizedScore = Math.max(0, Math.min(100, (score / maxPossibleScore) * 100));

  auditResults.overall.score = Math.round(normalizedScore);

  // Assign letter grade
  if (normalizedScore >= 90) auditResults.overall.grade = 'A';
  else if (normalizedScore >= 80) auditResults.overall.grade = 'B';
  else if (normalizedScore >= 70) auditResults.overall.grade = 'C';
  else if (normalizedScore >= 60) auditResults.overall.grade = 'D';
  else auditResults.overall.grade = 'F';
}

/**
 * Display audit results
 */
function displayResults() {
  console.log('\n🛡️ XSS Vulnerability Audit Results');
  console.log('=====================================\n');

  console.log(
    `📊 Overall Security Score: ${auditResults.overall.score}/100 (Grade: ${auditResults.overall.grade})`
  );
  console.log(
    `🎯 Summary: ${auditResults.overall.passed} passed, ${auditResults.overall.warnings} warnings, ${auditResults.overall.criticalIssues} critical issues\n`
  );

  Object.entries(auditResults.categories).forEach(([category, findings]) => {
    if (findings.length === 0) return;

    console.log(
      `📋 ${category
        .toUpperCase()
        .replace(/([A-Z])/g, ' $1')
        .trim()}:`
    );
    findings.forEach(finding => {
      const icon =
        finding.severity === 'critical' ? '🚨' : finding.severity === 'warning' ? '⚠️' : '✅';
      console.log(`  ${icon} ${finding.title}`);
      console.log(`     ${finding.description}`);
      if (finding.file) {
        const location = finding.line ? `${finding.file}:${finding.line}` : finding.file;
        console.log(`     File: ${location}`);
      }
      if (finding.codeSnippet) console.log(`     Code: ${finding.codeSnippet}`);
      console.log(`     Recommendation: ${finding.recommendation}\n`);
    });
  });

  // File-by-file summary
  console.log('📁 File-by-File Summary:');
  Object.entries(auditResults.files).forEach(([file, stats]) => {
    if (stats.criticalIssues + stats.warnings + stats.passed === 0) return;
    const icon = stats.criticalIssues > 0 ? '🚨' : stats.warnings > 0 ? '⚠️' : '✅';
    console.log(
      `  ${icon} ${file}: ${stats.passed} passed, ${stats.warnings} warnings, ${stats.criticalIssues} critical`
    );
  });

  // High-level recommendations
  console.log('\n🎯 Priority Recommendations:');
  if (auditResults.overall.criticalIssues > 0) {
    console.log('  🚨 Address all critical XSS vulnerabilities immediately');
  }
  if (auditResults.overall.warnings > 0) {
    console.log('  ⚠️ Review and address warning-level security concerns');
  }
  if (auditResults.overall.score >= 80) {
    console.log('  ✅ Good XSS protection - continue monitoring and updating');
  } else {
    console.log('  🔧 Significant XSS protection improvements needed');
  }

  console.log('\n🛡️ XSS Protection Recommendations:');
  console.log('  • Use textContent instead of innerHTML for dynamic content');
  console.log('  • Implement Content Security Policy (CSP) without unsafe-inline/unsafe-eval');
  console.log('  • Escape all user input before displaying in HTML context');
  console.log('  • Validate and sanitize all user inputs');
  console.log('  • Use parameterized queries and avoid dynamic code execution');
}

/**
 * Main audit execution
 */
function runXSSAudit() {
  console.log('🛡️ Starting XSS Vulnerability Audit...\n');

  // Analyze CSP first
  analyzeCSP();

  // Test XSS payload resistance
  testXSSPayloads();

  // Get all files to analyze
  console.log('🔍 Analyzing JavaScript and HTML files...');
  const files = getFilesToAnalyze();

  let filesAnalyzed = 0;
  files.forEach(filePath => {
    try {
      const content = readFileSync(filePath, 'utf8');
      analyzeFile(filePath, content);
      filesAnalyzed++;
    } catch (error) {
      // Skip files we can't read
    }
  });

  console.log(`📁 Analyzed ${filesAnalyzed} files for XSS vulnerabilities\n`);

  calculateSecurityScore();
  displayResults();

  // Save detailed results
  try {
    const resultsPath = join(projectRoot, 'xss-audit-results.json');
    writeFileSync(resultsPath, JSON.stringify(auditResults, null, 2));
    console.log(`\n📄 Detailed audit results saved to: xss-audit-results.json`);
  } catch (err) {
    console.log('\n📄 Results not saved due to filesystem access limitation');
  }

  return auditResults;
}

// Run the audit
runXSSAudit();
